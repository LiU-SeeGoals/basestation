/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: ssl_detection_tracked.proto */

#ifndef PROTOBUF_C_ssl_5fdetection_5ftracked_2eproto__INCLUDED
#define PROTOBUF_C_ssl_5fdetection_5ftracked_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Vector2 Vector2;
typedef struct _Vector3 Vector3;
typedef struct _RobotId RobotId;
typedef struct _TrackedBall TrackedBall;
typedef struct _KickedBall KickedBall;
typedef struct _TrackedRobot TrackedRobot;
typedef struct _TrackedFrame TrackedFrame;


/* --- enums --- */

/*
 * The team color of the robot
 */
typedef enum _TeamColor {
  /*
   * team not set
   */
  TEAM_COLOR__TEAM_COLOR_UNKNOWN = 0,
  /*
   * yellow team
   */
  TEAM_COLOR__TEAM_COLOR_YELLOW = 1,
  /*
   * blue team
   */
  TEAM_COLOR__TEAM_COLOR_BLUE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TEAM_COLOR)
} TeamColor;
/*
 * Capabilities that a source implementation can have
 */
typedef enum _Capability {
  CAPABILITY__CAPABILITY_UNKNOWN = 0,
  CAPABILITY__CAPABILITY_DETECT_FLYING_BALLS = 1,
  CAPABILITY__CAPABILITY_DETECT_MULTIPLE_BALLS = 2,
  CAPABILITY__CAPABILITY_DETECT_KICKED_BALLS = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CAPABILITY)
} Capability;

/* --- messages --- */

/*
 * A vector with two dimensions
 */
struct  _Vector2
{
  ProtobufCMessage base;
  float x;
  float y;
};
#define VECTOR2__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&vector2__descriptor) \
    , 0, 0 }


/*
 * A vector with three dimensions
 */
struct  _Vector3
{
  ProtobufCMessage base;
  float x;
  float y;
  float z;
};
#define VECTOR3__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&vector3__descriptor) \
    , 0, 0, 0 }


/*
 * A unique robot id with team information
 */
struct  _RobotId
{
  ProtobufCMessage base;
  /*
   * The robot number
   */
  uint32_t id;
  /*
   * The team color
   */
  TeamColor team_color;
};
#define ROBOT_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&robot_id__descriptor) \
    , 0, TEAM_COLOR__TEAM_COLOR_UNKNOWN }


/*
 * A single tracked ball
 */
struct  _TrackedBall
{
  ProtobufCMessage base;
  /*
   * The position (x, y, height) [m] in the ssl-vision coordinate system
   */
  Vector3 *pos;
  /*
   * The velocity [m/s] in the ssl-vision coordinate system
   */
  Vector3 *vel;
  /*
   * The visibility of the ball
   * A value between 0 (not visible) and 1 (visible)
   * The exact implementation depends on the source software
   */
  protobuf_c_boolean has_visibility;
  float visibility;
};
#define TRACKED_BALL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tracked_ball__descriptor) \
    , NULL, NULL, 0, 0 }


/*
 * A ball kicked by a robot, including predictions when the ball will come to a stop
 */
struct  _KickedBall
{
  ProtobufCMessage base;
  /*
   * The initial position [m] from which the ball was kicked
   */
  Vector2 *pos;
  /*
   * The initial velocity [m/s] with which the ball was kicked
   */
  Vector3 *vel;
  /*
   * The unix timestamp [s] when the kick was performed
   */
  double start_timestamp;
  /*
   * The predicted unix timestamp [s] when the ball comes to a stop
   */
  protobuf_c_boolean has_stop_timestamp;
  double stop_timestamp;
  /*
   * The predicted position [m] at which the ball will come to a stop
   */
  Vector2 *stop_pos;
  /*
   * The robot that kicked the ball
   */
  RobotId *robot_id;
};
#define KICKED_BALL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kicked_ball__descriptor) \
    , NULL, NULL, 0, 0, 0, NULL, NULL }


/*
 * A single tracked robot
 */
struct  _TrackedRobot
{
  ProtobufCMessage base;
  RobotId *robot_id;
  /*
   * The position [m] in the ssl-vision coordinate system
   */
  Vector2 *pos;
  /*
   * The orientation [rad] in the ssl-vision coordinate system
   */
  float orientation;
  /*
   * The velocity [m/s] in the ssl-vision coordinate system
   */
  Vector2 *vel;
  /*
   * The angular velocity [rad/s] in the ssl-vision coordinate system
   */
  protobuf_c_boolean has_vel_angular;
  float vel_angular;
  /*
   * The visibility of the robot
   * A value between 0 (not visible) and 1 (visible)
   * The exact implementation depends on the source software
   */
  protobuf_c_boolean has_visibility;
  float visibility;
};
#define TRACKED_ROBOT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tracked_robot__descriptor) \
    , NULL, NULL, 0, NULL, 0, 0, 0, 0 }


/*
 * A frame that contains all currently tracked objects on the field on all cameras
 */
struct  _TrackedFrame
{
  ProtobufCMessage base;
  /*
   * A monotonous increasing frame counter
   */
  uint32_t frame_number;
  /*
   * The unix timestamp in [s] of the data
   */
  double timestamp;
  /*
   * The list of detected balls
   * The first ball is the primary one
   * Sources may add additional balls based on their capabilities
   */
  size_t n_balls;
  TrackedBall **balls;
  /*
   * The list of detected robots of both teams
   */
  size_t n_robots;
  TrackedRobot **robots;
  /*
   * Information about a kicked ball, if the ball was kicked by a robot and is still moving
   * Note: This field is optional. Some source implementations might not set this at any time
   */
  KickedBall *kicked_ball;
  /*
   * List of capabilities of the source implementation
   */
  size_t n_capabilities;
  Capability *capabilities;
};
#define TRACKED_FRAME__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tracked_frame__descriptor) \
    , 0, 0, 0,NULL, 0,NULL, NULL, 0,NULL }


/* Vector2 methods */
void   vector2__init
                     (Vector2         *message);
size_t vector2__get_packed_size
                     (const Vector2   *message);
size_t vector2__pack
                     (const Vector2   *message,
                      uint8_t             *out);
size_t vector2__pack_to_buffer
                     (const Vector2   *message,
                      ProtobufCBuffer     *buffer);
Vector2 *
       vector2__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   vector2__free_unpacked
                     (Vector2 *message,
                      ProtobufCAllocator *allocator);
/* Vector3 methods */
void   vector3__init
                     (Vector3         *message);
size_t vector3__get_packed_size
                     (const Vector3   *message);
size_t vector3__pack
                     (const Vector3   *message,
                      uint8_t             *out);
size_t vector3__pack_to_buffer
                     (const Vector3   *message,
                      ProtobufCBuffer     *buffer);
Vector3 *
       vector3__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   vector3__free_unpacked
                     (Vector3 *message,
                      ProtobufCAllocator *allocator);
/* RobotId methods */
void   robot_id__init
                     (RobotId         *message);
size_t robot_id__get_packed_size
                     (const RobotId   *message);
size_t robot_id__pack
                     (const RobotId   *message,
                      uint8_t             *out);
size_t robot_id__pack_to_buffer
                     (const RobotId   *message,
                      ProtobufCBuffer     *buffer);
RobotId *
       robot_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   robot_id__free_unpacked
                     (RobotId *message,
                      ProtobufCAllocator *allocator);
/* TrackedBall methods */
void   tracked_ball__init
                     (TrackedBall         *message);
size_t tracked_ball__get_packed_size
                     (const TrackedBall   *message);
size_t tracked_ball__pack
                     (const TrackedBall   *message,
                      uint8_t             *out);
size_t tracked_ball__pack_to_buffer
                     (const TrackedBall   *message,
                      ProtobufCBuffer     *buffer);
TrackedBall *
       tracked_ball__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tracked_ball__free_unpacked
                     (TrackedBall *message,
                      ProtobufCAllocator *allocator);
/* KickedBall methods */
void   kicked_ball__init
                     (KickedBall         *message);
size_t kicked_ball__get_packed_size
                     (const KickedBall   *message);
size_t kicked_ball__pack
                     (const KickedBall   *message,
                      uint8_t             *out);
size_t kicked_ball__pack_to_buffer
                     (const KickedBall   *message,
                      ProtobufCBuffer     *buffer);
KickedBall *
       kicked_ball__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kicked_ball__free_unpacked
                     (KickedBall *message,
                      ProtobufCAllocator *allocator);
/* TrackedRobot methods */
void   tracked_robot__init
                     (TrackedRobot         *message);
size_t tracked_robot__get_packed_size
                     (const TrackedRobot   *message);
size_t tracked_robot__pack
                     (const TrackedRobot   *message,
                      uint8_t             *out);
size_t tracked_robot__pack_to_buffer
                     (const TrackedRobot   *message,
                      ProtobufCBuffer     *buffer);
TrackedRobot *
       tracked_robot__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tracked_robot__free_unpacked
                     (TrackedRobot *message,
                      ProtobufCAllocator *allocator);
/* TrackedFrame methods */
void   tracked_frame__init
                     (TrackedFrame         *message);
size_t tracked_frame__get_packed_size
                     (const TrackedFrame   *message);
size_t tracked_frame__pack
                     (const TrackedFrame   *message,
                      uint8_t             *out);
size_t tracked_frame__pack_to_buffer
                     (const TrackedFrame   *message,
                      ProtobufCBuffer     *buffer);
TrackedFrame *
       tracked_frame__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tracked_frame__free_unpacked
                     (TrackedFrame *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Vector2_Closure)
                 (const Vector2 *message,
                  void *closure_data);
typedef void (*Vector3_Closure)
                 (const Vector3 *message,
                  void *closure_data);
typedef void (*RobotId_Closure)
                 (const RobotId *message,
                  void *closure_data);
typedef void (*TrackedBall_Closure)
                 (const TrackedBall *message,
                  void *closure_data);
typedef void (*KickedBall_Closure)
                 (const KickedBall *message,
                  void *closure_data);
typedef void (*TrackedRobot_Closure)
                 (const TrackedRobot *message,
                  void *closure_data);
typedef void (*TrackedFrame_Closure)
                 (const TrackedFrame *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    team_color__descriptor;
extern const ProtobufCEnumDescriptor    capability__descriptor;
extern const ProtobufCMessageDescriptor vector2__descriptor;
extern const ProtobufCMessageDescriptor vector3__descriptor;
extern const ProtobufCMessageDescriptor robot_id__descriptor;
extern const ProtobufCMessageDescriptor tracked_ball__descriptor;
extern const ProtobufCMessageDescriptor kicked_ball__descriptor;
extern const ProtobufCMessageDescriptor tracked_robot__descriptor;
extern const ProtobufCMessageDescriptor tracked_frame__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_ssl_5fdetection_5ftracked_2eproto__INCLUDED */
